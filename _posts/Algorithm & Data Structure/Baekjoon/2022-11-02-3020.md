---
title: "[Baekjoon 3020] ê°œë˜¥ë²Œë ˆ" 

categories:
  - BOJ
tags:
  - [algorithm, binary_search, sorting]

toc: true
toc_sticky: true

toc_label: "Content"
toc_icon: "sticky-note"
---

## ë¬¸ì œ

### ğŸ’›â…¤ [[Baekjoon 3020-ê°œë˜¥ë²Œë ˆ]](https://www.acmicpc.net/problem/3020)

![image](https://user-images.githubusercontent.com/68420044/200182265-101ad307-2c3a-4c80-909f-cbaef3b51e13.png)


## ë¬¸ì œ í’€ì´ ë°©ë²•

> ì´ì§„ íƒìƒ‰ì„ ì‚¬ìš©í•˜ì—¬ í’€ì´í•´ì•¼ í•˜ëŠ” ë¬¸ì œì´ì§€ë§Œ, ì–´ëŠ ë¶€ë¶„ì—ì„œ ì´ì§„ íƒìƒ‰ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ì§€ë¥¼ íŒŒì•…í•˜ê¸°ê°€ í˜ë“¤ì—ˆë‹¤. ê·¸ë˜ì„œ ê·¸ëƒ¥ ê° ì¥ì• ë¬¼ì˜ ê¸¸ì´ì— ë”°ë¼ ë†’ì´ ë³„ count ë³€ìˆ˜ì— ê°’ì„ ì €ì¥í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì—ˆë”ë‹ˆ ì‹œê°„ì´ˆê³¼ê°€ ë–´ë‹¤. ì§ˆë¬¸ ê²Œì‹œíŒì„ ì°¸ê³ í•˜ì—¬ ì´ë¶„íƒìƒ‰ì„ ì–´ë””ì—ì„œ ì°¾ì•„ì•¼ í•˜ëŠ”ì§€ ì°¸ê³ í•˜ì—¬ ë‹¤ì‹œ í’€ì–´ë³´ì•˜ë‹¤!


1) ì²˜ìŒì— ì¥ì• ë¬¼ì„ ì„ìˆœ(ê¸¸ì´)ê³¼ ì¢…ìœ ì„(H-ê¸¸ì´)ì„ ë‚˜ëˆ„ì–´ ì…ë ¥ì„ ë°›ê³ , ê°ê° ì •ë ¬ì„ í•œë‹¤.

2) Hë§Œí¼ ë°˜ë³µë¬¸ì„ ëŒë©´ì„œ ê° ì¥ì• ë¬¼ ë°°ì—´( down_obstacle, up_obstacle )ì—ì„œ hë³´ë‹¤ í° ì¥ì• ë¬¼ì´ ìˆëŠ” indexë¥¼ ì°¾ëŠ”ë‹¤. ì´ ë•Œ ì´ë¶„íƒìƒ‰ì€ Pythonì˜ bisect ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í™œìš©í•˜ì˜€ë‹¤. 

3) ì¥ì• ë¬¼ì˜ ê°œìˆ˜ëŠ” down_obstacleì˜ ê²½ìš° (ë°°ì—´ì˜ ê¸¸ì´-index)ì´ê³ , up_abstacleì˜ ê²½ìš°ëŠ” ì°¾ì€ indexì´ë‹¤. 

4) ê° ë†’ì´ë§ˆë‹¤ ì„¼ ì¥ì• ë¬¼ì˜ ê°œìˆ˜ ë°°ì—´ì—ì„œ ìµœì†Ÿê°’ê³¼ ê·¸ ê°œìˆ˜ë¥¼ printí•œë‹¤. 

## í’€ì´ ì½”ë“œ

### Python - ì‹œê°„ì´ˆê³¼

```python
import sys
input = sys.stdin.readline

N, H = map(int, input().split())
obstacle = [int(input()) for _ in range(N)]

cnt = [0] * H
for i,x in enumerate(obstacle):
    if i%2==0:
        for idx in range(H-1,H-x-1,-1):
            cnt[idx]+=1
    else:
        for idx in range(0,x):
            cnt[idx] += 1

min_cnt = cnt[0]
answer = 0
for c in cnt:
    if min_cnt > c:
        min_cnt = c
        answer = 1
    elif min_cnt == c:
        answer += 1
print(min_cnt, answer)
```

### Python - í†µê³¼!

```python
from bisect import bisect_left, bisect_right
import sys
input = sys.stdin.readline

N, H = map(int, input().split())
down_obstacle = []
up_obstacle = []
for i in range(N):
    if i%2 == 0:
        down_obstacle.append(int(input()))
    else:
        up_obstacle.append(H - int(input()))
down_obstacle.sort()
up_obstacle.sort()

cnt = [0] * (H+1)
for i in range(1,H+1):
    cnt[i] = (N//2 - bisect_left(down_obstacle,i)+bisect_left(up_obstacle,i))

min_cnt = cnt[1]
answer = 0
for c in cnt[1:]:
    if min_cnt > c:
        min_cnt = c
        answer = 1
    elif min_cnt == c:
        answer += 1
print(min_cnt, answer)
```