---
title: "[Algorithm] Shortest Path"
categories:
  - Algorithm
tags:
  - [algorithm, shortest_path]

toc: true
toc_sticky: true
toc_label: "Content"
toc_icon: "sticky-note"
---

π“£<br>
λ³Έ ν¬μ¤νΈλ” 'μ΄κ²ƒμ΄ μ·¨μ—…μ„ μ„ν• μ½”λ”© ν…μ¤νΈλ‹¤ with νμ΄μ¬'μ„ κ³µλ¶€ν•κ³  μ‘μ„±ν•μ€μµλ‹λ‹¤ :)    
click > [(μ΄μ½”ν… 2021) μ΄κ²ƒμ΄ μ·¨μ—…μ„ μ„ν• μ½”λ”© ν…μ¤νΈλ‹¤ with νμ΄μ¬](https://www.youtube.com/watch?v=m-9pAwq1o3w)
{: .notice--primary}

# Shortest Path

## μ΄λ΅ 

**μµλ‹¨ κ²½λ΅(Shortest Path)** μ•κ³ λ¦¬μ¦μ€ νΉμ • μ§€μ κΉμ§€ κ°€μ¥ λΉ λ¥΄κ² λ„λ‹¬ν•λ” λ°©λ²•μ„ μ°Ύλ” μ•κ³ λ¦¬μ¦μ΄λ‹¤. μµλ‹¨ κ²½λ΅ μ•κ³ λ¦¬μ¦ μ ν•μ—λ” λ‹¤μ–‘ν• μΆ…λ¥κ°€ μλ”λ° μƒν™©μ— λ§λ” ν¨μ¨μ μΈ μ•κ³ λ¦¬μ¦μ΄ μ΄λ―Έ μ •λ¦½λμ–΄ μλ‹¤. 

μµλ‹¨ κ²½λ΅ λ¬Έμ λ” λ³΄ν†µ κ·Έλν”„λ¥Ό μ΄μ©ν•΄ κ° μ§€μ μ€ λ…Έλ“λ΅, μ§€μ κ°„ μ—°κ²°λ λ„λ΅λ” κ°„μ„ μΌλ΅ ν‘ν„λλ‹¤. β΅οΈ [**κ·Έλν”„μ ν‘ν„ λ°©μ‹**](https://www.notion.so/DFS-BFS-df7989316bb14dcea96dbc6b0520762f)

μµλ‹¨ κ²½λ΅ μ•κ³ λ¦¬μ¦λ” ν¬κ² 3μΆ…λ¥κ°€ μλ‹¤. 

- **λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦** : ν• μ§€μ μ—μ„ λ‹¤λ¥Έ νΉμ • μ§€μ κΉμ§€μ μµλ‹¨ κ²½λ΅λ¥Ό κµ¬ν•΄μ•Ό ν•λ” κ²½μ°
- **ν”λ΅μ΄λ“ μ›μ… μ•κ³ λ¦¬μ¦** : λ¨λ“  μ§€μ μ—μ„ λ‹¤λ¥Έ λ¨λ“  μ§€μ κΉμ§€μ μµλ‹¨ κ²½λ΅λ¥Ό λ¨λ‘ κµ¬ν•΄μ•Ό ν•λ” κ²½μ°
- **λ²¨λ§ ν¬λ“ μ•κ³ λ¦¬μ¦** : κ°„μ„ μ κ°€μ¤‘μΉκ°€ μμμΌ λ•, ν• λ…Έλ“μ—μ„ λ‹¤λ¥Έ λ…Έλ“κΉμ§€μ μµλ‹¨ κ±°λ¦¬λ¥Ό κµ¬ν•λ” μ•κ³ λ¦¬μ¦

### λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦

λ‹¤μµμ¤νΈλΌ μµλ‹¨ κ²½λ΅ μ•κ³ λ¦¬μ¦μ€ **κ·Έλν”„μ—μ„ μ—¬λ¬ κ°μ λ…Έλ“κ°€ μμ„ λ•, νΉμ •ν• λ…Έλ“μ—μ„ μ¶λ°ν•μ—¬ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” κ°κ°μ μµλ‹¨ κ²½λ΅**λ¥Ό κµ¬ν•΄μ£Όλ” μ•κ³ λ¦¬μ¦μ΄λ‹¤. 

λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ€ λ§¤λ² κ°€μ¥ λΉ„μ©μ΄ μ μ€ λ…Έλ“λ¥Ό μ„ νƒν•κΈ° λ•λ¬Έμ— **κ·Έλ¦¬λ”” μ•κ³ λ¦¬μ¦**μΌλ΅ λ¶„λ¥λλ‹¤. μ•κ³ λ¦¬μ¦μ μ›λ¦¬λ” λ‹¤μκ³Ό κ°™λ‹¤. 

1οΈβƒ£ μ¶λ° λ…Έλ“λ¥Ό μ„¤μ •ν•λ‹¤. 

2οΈβƒ£ μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ μ΄κΈ°ν™”ν•λ‹¤. 

3οΈβƒ£ λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•λ‹¤. 

4οΈβƒ£ ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ„ κ³„μ‚°ν•μ—¬ μµλ‹¨κ±°λ¦¬ ν…μ΄λΈ”μ„ κ°±μ‹ ν•λ‹¤ 

5οΈβƒ£ 3-4κ³Όμ •μ„ λ°λ³µν•λ‹¤. 

**κµ¬ν„ μ½”λ“**

```python
def dijkstra(start, distance, graph):
    q = []
    heapq.heappush(q,(0,start))
    distance[start] = 0
    while q:
        dist, node = heapq.heappop(q)
        if distance[node] < dist: # μ΄λ―Έ μ²λ¦¬ν• μ  μλ” λ…Έλ“λΌλ©΄ λ¬΄μ‹
            continue
        for i in graph[node]: # ν„μ¬ λ…Έλ“μ™€ μ—°κ²°λ λ…Έλ“λ“¤ ν™•μΈ
            cost = dist+i[1] # κ±°λ¦¬ κ³„μ‚°
            if cost < distance[i[0]]: # ν„μ¬ μµλ‹¨κ±°λ¦¬λ³΄λ‹¤ μ‘λ‹¤λ©΄ κ°±μ‹ ν•κ³  ν™μ— push
                distance[i[0]] = cost
                heapq.heappush(q,(cost, i[0]))
```

**μ‹κ°„ λ³µμ΅λ„**

- μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ λ¦¬μ¤νΈλ΅ κµ¬ν„ν–μ„ λ• β†’ $O(V^2)$
- μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ μ°μ„ μμ„ ν(heap)μΌλ΅ κµ¬ν„ν–μ„ λ• β†’ $O(E*logV)$

### ν”λ΅μ΄λ“ μ›μ… μ•κ³ λ¦¬μ¦

ν”λ΅μ΄λ“ μ›μ… μ•κ³ λ¦¬μ¦μ€ **λ¨λ“  μ§€μ μ—μ„ λ‹¤λ¥Έ λ¨λ“  μ§€μ κΉμ§€μ μµλ‹¨ κ²½λ΅λ¥Ό λ¨λ‘ κµ¬ν•΄μ•Ό ν•λ” κ²½μ°**μ— μ‚¬μ©ν•  μ μλ” μ•κ³ λ¦¬μ¦μΌλ΅ μ ν™”μ‹μ— λ§κ² λ™μ‘ν•κΈ° λ•λ¬Έμ— **λ‹¤μ΄λ‚λ―Ή ν”„λ΅κ·Έλλ°**μΌλ΅ λ³Ό μ μλ‹¤. 

λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ€ λ‹¨κ³„λ§λ‹¤ λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬λ¥Ό κ°€μ§€λ” λ…Έλ“λ¥Ό ν•λ‚μ”© μ„ νƒν•λ‹¤. κ·Έλ¦¬κ³  ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ κ°€λ” κ²½λ΅λ¥Ό ν™•μΈν•λ©° μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”(1μ°¨μ› λ¦¬μ¤νΈ)λ¥Ό κ°±μ‹ ν•λ” λ°©μ‹μ΄λ‹¤. 

ν”λ΅μ΄λ“ μ›μ… μ•κ³ λ¦¬μ¦μ€ λ‹¨κ³„λ§λ‹¤ ν„μ¬ λ…Έλ“λ¥Ό κ±°μ³ κ°€λ” λ¨λ“  κ²½λ΅λ¥Ό κ³ λ ¤ν•λ‹¤. λ¨λ“  λ…Έλ“μ— λ€ν•μ—¬ λ‹¤λ¥Έ λ¨λ“  λ…Έλ“λ΅ κ°€λ” μµλ‹¨ κ±°λ¦¬ μ •λ³΄λ¥Ό λ¨λ‘ λ‹΄μ•„μ•Ό ν•κΈ° λ•λ¬Έμ— 2μ°¨μ›μ μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”λ΅ μ •λ³΄λ¥Ό μ²λ¦¬ν•λ‹¤. μ•κ³ λ¦¬μ¦μ μ›λ¦¬λ” λ‹¤μκ³Ό κ°™λ‹¤. 

1οΈβƒ£ ν„μ¬ ν™•μΈν•κ³  μλ” λ…Έλ“λ¥Ό μ μ™Έν•κ³ , N-1κ°μ λ…Έλ“ μ¤‘μ—μ„ μ„λ΅ λ‹¤λ¥Έ λ…Έλ“ (A, B) μμ„ μ„ νƒν•λ‹¤. 

2οΈβƒ£ A β†’ ν„μ¬ λ…Έλ“ β†’ Bλ΅ κ°€λ” λΉ„μ©μ„ ν™•μΈν•κ³  μµλ‹¨ κ±°λ¦¬λ¥Ό κ°±μ‹ ν•λ‹¤. 

κ° λ‹¨κ³„μ—μ„ μµλ‹¨ κ±°λ¦¬λ¥Ό κ°±μ‹ ν•λ” μ ν™”μ‹μ€ $D_{ab} = min(D_{ab}, D_{ak}+D_{kb})$ μ΄λ‹¤. 

**κµ¬ν„ μ½”λ“**

```python
for k in range(1,n+1):
    for i in range(1,n+1):
        for j in range(1,n+1):
            graph[i][j] = min(graph[i][j], graph[i][k]+graph[k][j])
```

**μ‹κ°„ λ³µμ΅λ„**

Nκ°μ λ…Έλ“μ— λ€ν•΄μ„ $_{n-1}P_2$κ°μ μμ„ λ°λ³µν•΄μ„ ν™•μΈν•λ©΄ λλ―€λ΅ $O(N^3)$μ΄λΌκ³  ν•  μ μλ‹¤. 

### λ²¨λ§ ν¬λ“ μ•κ³ λ¦¬μ¦

λ²¨λ§ ν¬λ“ μ•κ³ λ¦¬μ¦μ€ λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦κ³Ό λ‘κ°™μ΄ ν• λ…Έλ“μ—μ„ λ‹¤λ¥Έ λ…Έλ“κΉμ§€ μµλ‹¨ κ±°λ¦¬λ¥Ό κµ¬ν•λ” μ•κ³ λ¦¬μ¦μ΄λ‹¤. μ°¨μ΄μ μ€ λ²¨λ§ ν¬λ“ μ•κ³ λ¦¬μ¦μ€ κ°„μ„ μ κ°€μ¤‘μΉκ°€ μμμΌ λ•λ„ μµλ‹¨ κ±°λ¦¬λ¥Ό κµ¬ν•  μ μλ‹¤λ” μ μ΄λ‹¤. μ•κ³ λ¦¬μ¦μ μ›λ¦¬λ” λ‹¤μκ³Ό κ°™λ‹¤. 

1οΈβƒ£ μ¶λ° λ…Έλ“λ¥Ό μ„¤μ •ν•λ‹¤. 

2οΈβƒ£ μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ μ΄κΈ°ν™”ν•λ‹¤. 

3οΈβƒ£ λ¨λ“  κ°„μ„  Eκ°λ¥Ό ν•λ‚μ”© ν™•μΈν•λ‹¤.

4οΈβƒ£ ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ„ κ³„μ‚°ν•μ—¬ μµλ‹¨κ±°λ¦¬ ν…μ΄λΈ”μ„ κ°±μ‹ ν•λ‹¤ 

5οΈβƒ£ 3-4κ³Όμ •μ„ λ°λ³µν•λ‹¤. 

β… **μμ κ°„μ„  μν™(cycle) λ°μƒμ„ ν™•μΈ!**    
4οΈβƒ£λ² κ³Όμ •μ„ ν• λ² λ” μν–‰ν•κ³  μ΄λ• μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ΄ κ°±μ‹ λλ”μ§€λ¥Ό ν™•μΈν•λ‹¤. κ°±μ‹ λλ” κ²½μ° μμ κ°„μ„  μν™μ΄ μ΅΄μ¬ν•λ‹¤λ” κ²ƒμ΄λ‹¤.   
μμ κ°„μ„  μν™μ΄ μ΅΄μ¬ν•λ” κ²½μ° λΉ„μ©μ„ λ¬΄ν•ν μ¤„μΌ μ μκΈ° λ•λ¬Έμ— μµλ‹¨ κ±°λ¦¬λ¥Ό μν•  μ μ—†κ² λλ―€λ΅ κΌ­ ν™•μΈν•΄μ•Ό ν•λ‹¤.
{: .notice--success}

**κµ¬ν„ μ½”λ“**

```python
def bellmanFord(start):
    distance[start] = 0
    for i in range(v): # μ „μ²΄ v - 1λ² λ°λ³µ
        for j in range(e): # λ§¤ λ°λ³µλ§λ‹¤ 'λ¨λ“  κ°„μ„ 'μ„ ν™•μΈν•λ‹¤.
            cur_node = edges[j][0]
            next_node = edges[j][1]
            edge_cost = edges[j][2]
            # ν„μ¬ κ°„μ„ μ„ κ±°μ³μ„ λ‹¤λ¥Έ λ…Έλ“λ΅ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ€ κ²½μ°
            if distance[cur_node] != INF and distance[next_node] > distance[cur_node] + edge_cost:
                distance[next_node] = distance[cur_node] + edge_cost
                # vλ²μ§Έ λΌμ΄λ“μ—μ„λ„ κ°’μ΄ κ°±μ‹ λλ‹¤λ©΄ μμ μν™μ΄ μ΅΄μ¬
                if i == v - 1:
                    return True
    return False
```

REF : [https://deep-learning-study.tistory.com/587](https://deep-learning-study.tistory.com/587) 

**μ‹κ°„ λ³µμ΅λ„**

λ¨λ“  λ…Έλ“μ—μ„ λ¨λ“  κ°„μ„ μ„ ν™•μΈν•λ―€λ΅ **O(VE)**μ΄λ‹¤.

## μ‹¤μ „ **λ¬Έμ **

### [μ‹¤μ „λ¬Έμ  1] λ―Έλλ„μ‹

```python
INF = int(1e9)

n, m = map(int, input().split())
graph = [[INF] * (n+1) for _ in range(n+1)]

for a in range(1,n+1):
		for b in range(1,n+1):
				if a == b: 
						graph[a][b] = 0 # μκΈ° μμ‹  λΉ„μ©μ€ 0μΌλ΅ μ΄κΈ°ν™”

for _ in range(m):
		a, b = map(int, input().split())
		graph[a][b] = 1
		graph[b][a] = 1

x, k = map(int, input().split())

for k in range(1, n+1):
		for i in range(1, n+1):
				for j in range(1, n+1):
						graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])

distance = graph[1][k] + graph[k][x]

if distance >= INF:
		print(-1)
else:
		print(distance)
```

### [μ‹¤μ „λ¬Έμ  2] μ „λ³΄

```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9) # λ¬΄ν•μ„ μλ―Έν•λ” κ°’μΌλ΅ 10μ–µμ„ μ„¤μ •

# λ…Έλ“μ κ°μ, κ°„μ„ μ κ°μ, μ‹μ‘ λ…Έλ“λ¥Ό μ…λ ¥λ°›κΈ°
n, m, start = map(int, input().split())
# κ° λ…Έλ“μ— μ—°κ²°λμ–΄ μλ” λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό λ‹΄λ” λ¦¬μ¤νΈλ¥Ό λ§λ“¤κΈ°
graph = [[] for i in range(n + 1)]
# μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ λ¨λ‘ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”
distance = [INF] * (n + 1)

# λ¨λ“  κ°„μ„  μ •λ³΄λ¥Ό μ…λ ¥λ°›κΈ°
for _ in range(m):
    x, y, z = map(int, input().split())
    # Xλ² λ…Έλ“μ—μ„ Yλ² λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ΄ ZλΌλ” μλ―Έ
    graph[x].append((y, z))

def dijkstra(start):
   q = []
   # μ‹μ‘ λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ²½λ΅λ” 0μΌλ΅ μ„¤μ •ν•μ—¬, νμ— μ‚½μ…
   heapq.heappush(q, (0, start))
   distance[start] = 0
   while q: # νκ°€ λΉ„μ–΄μμ§€ μ•λ‹¤λ©΄
        # κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό κΊΌλ‚΄κΈ°
        dist, now = heapq.heappop(q)
        if distance[now] < dist:
            continue
        # ν„μ¬ λ…Έλ“μ™€ μ—°κ²°λ λ‹¤λ¥Έ μΈμ ‘ν• λ…Έλ“λ“¤μ„ ν™•μΈ
        for i in graph[now]:
            cost = dist + i[1]
            # ν„μ¬ λ…Έλ“λ¥Ό κ±°μ³μ„, λ‹¤λ¥Έ λ…Έλ“λ΅ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ€ κ²½μ°
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

# λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ„ μν–‰
dijkstra(start)

# λ„λ‹¬ν•  μ μλ” λ…Έλ“μ κ°μ
count = 0
# λ„λ‹¬ν•  μ μλ” λ…Έλ“ μ¤‘μ—μ„, κ°€μ¥ λ©€λ¦¬ μλ” λ…Έλ“μ™€μ μµλ‹¨ κ±°λ¦¬
max_distance = 0
for d in distance:
    # λ„λ‹¬ν•  μ μλ” λ…Έλ“μΈ κ²½μ°
    if d != 1e9:
        count += 1
        max_distance = max(max_distance, d)

# μ‹μ‘ λ…Έλ“λ” μ μ™Έν•΄μ•Ό ν•λ―€λ΅ count - 1μ„ μ¶λ ¥
print(count - 1, max_distance)
```